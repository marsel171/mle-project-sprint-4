# Проект
# Создание рекомендательной системы для музыкального сервиса Яндекс Музыка

## Ноутбук 
Код для построения пайплайна для расчёта персональных рекомендаций находится в файле `recommendations.ipynb`. 

### Этапы работ в ноутбуке включают в себя:
 - Первичную подготовку данных
 - Анализ данных и их подготовку
 - Расчет рекомендаций нескольких типов
 - Оценку качества трёх типов рекомендаций
 - Построение ранжирующей модели

### Исходные данные

Данные находятся в трёх файлах.
Данные о треках — в файле `tracks.parquet`:

    track_id — идентификатор музыкального трека;
    albums —  список идентификаторов альбомов, содержащих трек;
    artists — список идентификаторов исполнителей трека;
    genres — список идентификаторов жанров, к которым принадлежит трек.

Имена артистов, названия альбомов, треков и жанров — в файле `catalog_names.parquet`:

    id — идентификатор одной из каталожных единиц (трека, альбома, исполнителя, жанра);
    type — тип идентификатора;
    name — имя (название) каталожной единицы.

Данные о том, какие пользователи прослушали тот или иной трек, — в файле `interactions.parquet`:

    user_id — идентификатор пользователя,
    track_id — идентификатор музыкального трека,
    track_seq — номер места трека в истории пользователя,
    started_at — дата начала прослушивания трека.

### Файлы с рекомендациями:

 - топ популярных — в `top_popular.parquet`
 - персональные (при помощи ALS) — в `personal_als.parquet`
 - похожие треки (i2i при помощи ALS) — в `similar.parquet`
 - итоговые рекомендации — в `recommendations.parquet`


## Сервис рекомендаций
Код сервиса находится в файле `recommendations_service.py`.

Необходимые библиотеки описаны в `requirements.txt`

### Необходимые шаги для запуска сервиса рекомендаций:
 - Запуск из командной строки в папке с кодом:

    `uvicorn recommendations_service:app`

 - Сервис поднимается по адресу http://127.0.0.1:8000 (по умолчанию)
 
 - Описание эндпоинтов сервиса:
    
    `/recommendations` - Основной метод, который принимает запрос с идентификатором пользователя `user_id` и выдаёт рекомендации, учитывая историю пользователя и смешивая онлайн- и офлайн-рекомендации.

    `/get_online_u2i` - Возвращает список онлайн-рекомендаций по k-последним событиям пользователя `user_id`, и по N-похожим трекам на каждое событие. Рекомендации генерируются обученной в ноутбуке моделью ALS (`als_model.npz`), которая загружается при запуске сервиса. Треки предварительно кодируются из `track_id` в `track_id_enc` и потом обратно энкодируются. Для этих целей при запуске сервиса подгружается файл `items.parquet`, в котором хранятся закодированные идентификаторы треков.

    `/put_user_event` - Сохраняет событие для `user_id`, `item_id`.

    `/get_user_events` - Возвращает список последних k событий для пользователя `user_id`.


    `/load_recommendations` - Загружает оффлайн-рекомендации из файла (на случай, если файлы рекомендаций обновились).


    `/get_statistics` - Выводит статистику по имеющимся счётчикам.


## Инструкции для тестирования сервиса

Код для тестирования сервиса находится в файле `test_service.py`.

### Необходимые шаги для тестирования сервиса рекомендаций

 - Запрос на получение ответа от сервиса рекомендаций:
    
    1) Для пользователя `user_id = 47` отправляется POST-запрос по адресу
    
        'http://127.0.0.1:8000/recommendations'

        Получим персональные рекомендации (в консоли видим "Found 100 personal recommendations!"):
        
        `{'recs': [977, 975, 973, 971,...}`

    2) Для "холодного" пользователя `user_id = 47000000000` 

        получим ТОП-рекомендации (в консоли видим "Found 100 TOP-recommendations!"):
        
        `{'recs': [47627256, 51516485, 24692821, 32947997, 55561798,...} `

 - Запрос на вывод статистики:

    отправляется GET-запрос по адресу
    
    'http://127.0.0.1:8000/get_statistics'

    получим:

    `{'request_personal_count': 1, 'request_default_count': 1}`

 - Запрос на события:

    1) Убедимся, что вначале нет событий для пользователя `user_id = 16` 
    
        'http://127.0.0.1:8000/get_user_events'
        
        получим:

        `{'events': []}`

    2) Добавим событий событий в цикле для того же пользователя `user_id = 16` 
    
        'http://127.0.0.1:8000/put_user_event'

        679169 - [Thunderstruck] [AC/DC]	
        630670 - [You're Gonna Go Far, Kid] [The Offspring]	
        646516 - [Chop Suey!] [System of A Down]	
        19152669 - [Centuries] [Fall Out Boy]
        38646012 - [Another Brick In The Wall, Pt. 2] [Pink Floyd]
        
        получим:
        
        679169
        {'result': 'ok'}

        630670
        {'result': 'ok'}

        646516
        {'result': 'ok'}

        19152669
        {'result': 'ok'}

        38646012
        {'result': 'ok'}

    3) Убедимся, что эти события появились для пользователя `user_id = 16` 
    
        'http://127.0.0.1:8000/get_user_events'
        
        получим:
        
        {'events': [38646012, 19152669, 646516, 630670, 679169, 679169]}

 - Запрос на получение итоговых (смешанных) рекомендаций для пользователя `user_id = 16`
    
        'http://127.0.0.1:8000/recommendations'
        
        получим:
        
        {'recs': [672687, 2278985, 647040, 3616433, 654151, 630670, 694683, 10270285,...}

        А список треков выглядит так:

        online rec track name:  ['Toxicity']
        online rec artist name:  ['System of A Down']
        online rec track name:  ['Rolling In The Deep']
        online rec artist name:  ['Adele']
        online rec track name:  ['Back in Black']
        online rec artist name:  ['AC/DC']
        online rec track name:  ['Summertime Sadness']
        online rec artist name:  ['Lana Del Rey']
        online rec track name:  ["The Kids Aren't Alright"]
        online rec artist name:  ['The Offspring']
        online rec track name:  ["You're Gonna Go Far, Kid"]
        online rec artist name:  ['The Offspring']
        online rec track name:  ['Highway to Hell']
        online rec artist name:  ['AC/DC']
        online rec track name:  ['Young And Beautiful']
        online rec artist name:  ['Lana Del Rey']
        и т.д.

### ВЫВОДЫ:

    Рекомендации выглядят отлично!
    Микросервис успешно принимает запросы с идентификатором пользователя и возвращает рекомендации. 
    Учтена история пользователя при выдаче рекомендаций. 
    Описана стратегия смешивания онлайн- и офлайн-рекомендаций в README. 
    Проведено тестирование микросервиса для разных типов пользователей, код оформлен в test_service.py.


 
